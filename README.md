# JavaDesignPattern
design pattern written by Java

# 面向对象的六大原则
* 单一职责原则:一个类应该仅有一个引起它变化的原因。
* 开闭原则:一个类应该只可扩展,不可修改。
* 里氏替换原则:子类能够替换他们的父类。
* 依赖倒置原则:依赖于抽象,不依赖于具体类:
  1. 高层模块不依赖底层模块,二者都应该依赖于抽象。【汽车不依赖于一个具体的车轮,而应该通过set车轮来依赖于车轮的抽象】
  2. 抽象不应该依赖于具体实现, 具体实现应该依赖于抽象。【抽象的轮子也能用,不一定要具体的轮子,反而,具体的轮子应该满足抽象轮子的功能】
* 接口隔离原则:不应该强迫客户依赖于他们不用的方法。
* 最少知识原则:只和你的朋友谈话。
* 其他原则:
  * 面向接口编程
  * 优先使用组合,不是继承
  * 一个类需要的数据应该隐藏在类内部
  * 类之间应该0耦合,或只有传导耦合,换句话说,类之间要么没关系,要么只使用另一个类的接口提供的操作
  * 水平方向上尽可能统一地分布系统功能

# 26个设计模式
### 单例模式
包括:
1. CEOSingleTon【饿汉模式：声明静态变量时就已经初始化了】
2. DCLSingleTon(Double Check Lock)【双重锁模式】
  * 优点: 既能够在需要时才初始化单例，又能够保证线程安全，而且，单例对象初始化后的getInstance调用是不会进行同步锁的。
  * 缺点: DCL失效问题：JDK1.5之前的JMM（Java内存模型）中的Cache、寄存器到主内存回写顺序的规定，① 分配内存 ②创建对象和对象引用 ③让对象引用指向对象  这三个步骤的执行顺序有时会错乱
  * 解决方法: v1.5之后, 采用 volatile 关键字【volatile修饰的变量,线程在每次进行"read and load"时,都会读取该变量修改后的最终值, 注意: jvm虚拟机只是保证从主存加载到线程工作内存的值是最新的,不保证"use and assign"和"store and write"过程的同步】
3. EnumSingleTon【枚举】
  * 枚举本身就是一个单例模式
  * 优点：解决了对象反序列化的问题（任何时候，都是单例模式）
  * 关于反序列化问题：即使你的构造函数是private的，反序列化依然会通过特殊途径来调用该方法来创建这个类新的实例
  * 序列化：通过序列化，可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获取一个实例。
4. LazySingleTon【懒汉模式：第一次调用getInstance()方法时，才进行初始化单例】
5. SingleTonManager【使用容器(如Map)实现单例模式】
6. StaticSingleTon【静态内部类单例】

### Builder模式
例子:
主要用于在原来的各种Computer的各种不同的具体实现类(如:Mac、Win10等)的基础上,对他们的构造、赋值细节都进行遮掩,用不同的Builder,去封装不同的Computer。

### 工厂模式
用一个Factory工厂类
### 抽象工厂模式
抽象工厂类,多个实现,这样,对于同一类产品(抽象产品类),可以有不同加工构建,而一类产品又有不同的实现类
### 策略模式
是解耦的一种关键模式,使用者与实现,都依赖于抽象,相当于: 不同使用者  --->  同一个抽象  <--- 不同实现(根据使用的策略)
### 状态模式
与策略模式一致的解耦思想(依赖倒置原则),只是,抽象的不同实现 会根据当前设置的状态不同而被重新设置(setter)
### 责任链模式

### 解释器模式
### 命令模式
### 观察者模式
### 备忘录模式
### 迭代器模式
### 模板模式
### 访问者模式
### 中介者模式
### 代理模式
### 组合模式
* component【部件】
* composite【组合】
* 本质: 一个类中,可以有一个本类的数组的引用,相当于,文件和文件夹都属于文件,但是文件夹可以包含多个文件。

### 适配器模式
### 装饰模式
### 享元模式
### 外观模式
外观模式【又称 门面模式】: 比如,手机有拨号和拍照功能,手机可以同时持有拨号类和拍照类对象引用,然后,对外提供统一的操作接口,这样,就是没人知道,手机内部有两个对象引用,也不知道手机的实际操作实际是内部两个对象的各个方法的调用。
* 精髓: '封装'。通过高层次结构的一个统一API,使得用户仅仅通过这些API,就可以基础操控整个系统 【说明这个模式是属于对高层的设计模式】
* 定义: 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。Facade模式提供一个高层次的接口,使得子系统更易于使用。
* 使用场景:
  1. 为一个复杂子系统提供一个简单接口。
        因为:大多数模式使用时都会产生更多、更小的类,而导致子系统更具可重用性和可定制和修改,这样一来,易变性 让 '如何隐藏子系统的具体实现' 变得重要。
        所以: Facade模式提供一个简单统一的接口,对外隐藏子系统的具体实现、隔离变化。
  2. 当需要构建一个层次结构的子系统时,使用Facade模式定义子系统中每层的入口点。(可以简化子系统之间的依赖关系)
* 优点:【很多第三方SDK使用的模式,就是这种模式,让SDK容易使用的】
  1. 对客户端隐藏子系统细节,因而减少客户对子系统的耦合, 能够拥抱变化。
  2. 外观类对子系统的接口封装, 是系统更容易使用。
* 缺点:
  1. 外观类接口膨胀。【由于外观类集合了各个子系统的使用接口,外观类的API接口较多,一定程度上增加了用户的使用成本】
  2. 外观类没有遵循开闭原则, 当业务变更时, 可能要直接修改外观类。

### 桥接模式
* 桥接模式:【可以理解一下: ①笛卡尔积 ②x轴和y轴的二维关系 ③ 抽象依赖抽象, 两个抽象的各个实现随意】
* 结构型设计模式
* 定义: 将抽象部分与实现部分分离 , 使它们都可以独立进行变化。【连接 '抽象部分' 和 '实现部分'】
* 优点: 抽象和实现部分分离
* 缺点: 难把握那个'度'